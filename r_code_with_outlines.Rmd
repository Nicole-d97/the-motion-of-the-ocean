## packages needed

```{r}
library(dplyr)
library(ggplot)
library (readr) 
library(vegan)
library(ggplot2)
library(tidyverse)
library(sp)
library(raster)
library(ape)
library(lawstat) 
library(rcompanion)
library(lme4)
library(MuMIn)
library(lawstat)
library(nlme)
```

## files needed

```{r}
invert_genera <- read_csv("invert.genera.season.csv")
cleaned.final.ph <- read_csv("FINAL.PH.GEO.csv") 
```

## Map of the sites

```{r}
map.US <- map_data("world", region = "USA")

invert_genera %>%
  ggplot() + 
  geom_polygon(data = map.US, aes(x = long, y = lat, group = group), fill = NA, colour = "gray") + 
  coord_fixed() + 
  geom_point(data = invert_genera, aes(x = decimalLongitude.x, y = decimalLatitude.x)) + 
  xlim(-200, -50) + 
  xlab("Longitude") + ylab("Latitude")
```

## Inverse distance weight matrix for testing spatial autocorrelation

```{r}
coord_invert <- SpatialPoints(cbind(invert_evenness_coords$decimalLongitude, invert_evenness_coords$decimalLatitude), 
proj4string=CRS("+proj=longlat +ellps=WGS84"))

UTM.US <- spTransform(coord_invert, CRS("+init=epsg:2163")) # US National Atlas Equal Area

dist.matrix <- as.matrix(dist(data.frame(UTM.US)))

inv.dist<- 1/dist.matrix

diag(inv.dist) <- 0

# getting rid of infinite values
inv.dist[is.infinite(inv.dist)] <- 0
```

# 1)	Measuring pH variability across sites and seasons
-	The effect of site, year, and season on pH:
o	Simple boxplots by sites and seasons: 3 for each site 
o	there is code that tests for 4 assumptions of normality – do that before running linear model 
o	Run multiple models with different structures: run AIC for the best structure 
o	Account for spatial autocorrelation 
o	Identify which variable to include as random effect (whatever the fixed effect is) 

``` {r}
# Removing outliers that don't fit within the normal range of pH values (ie. 0-14)
cleaned.final.ph<- FINAL.PH %>% 
  filter(pH < 14 & pH > 0)
cleaned.final.ph

# Testing for normality - overall pH 
cleaned.final.ph %>% 
ggplot(aes(x= pH)) + 
  geom_histogram()

# Testing for normality - pH by season 
cleaned.final.ph %>% 
ggplot(aes(x= pH)) + 
  geom_histogram() + 
  facet_wrap(~Season)

# Testing for normality - pH by siteID
cleaned.final.ph %>% 
ggplot(aes(x= pH)) + 
  geom_histogram() + 
  facet_wrap(~siteID)

# Testing for normality - pH by year 
cleaned.final.ph %>% 
ggplot(aes(x= pH)) + 
  geom_histogram() + 
  facet_wrap(~year)

# Testing for normality - pH by month
cleaned.final.ph %>% 
ggplot(aes(x= pH)) + 
  geom_histogram() + 
  facet_wrap(~month)
# not enough data by month = removed from pH.lm 

# Model that includes all as fixed effects 
pH.lm<- lm(pH~Season*siteID, data= cleaned.final.ph)

par(mfrow=c(2,2))
plot(pH.lm)
# Looking at panels 1 and 2, the data is homogenous and normally distributed 

# boxplots to visualize variation in pH across sites 
cleaned.final.ph %>% 
  ggplot(aes(x= siteID, y= pH))+ 
  geom_boxplot()

# boxplots to visualize variation in pH across seasons 
cleaned.final.ph %>% 
  ggplot(aes(x= Season, y= pH))+ 
  geom_boxplot()

# boxplots to visualize variation in pH across seasons and sites
cleaned.final.ph %>% 
  ggplot(aes(x= Season, y= pH))+ 
  geom_boxplot() + 
  facet_wrap(~siteID)

# Independence of residuals 
lawstat::runs.test(pH.lm$residuals)
# p value is 0.08 -> i.e no autocorrelation 

# Saturated Model 
```{r}
pH.lm.sat<-lmer(pH~Season*siteID +(1|year) +(1|month), data= cleaned.final.ph)
summary(pH.lm.sat)
```


# AIC values 
```{r}
cleaned.final.ph

n<- 74 
k<- 4 

AIC_mod <- n/k 

AIC_mod

#USING AICc because n/k is 18.5 (i.e less than 40)

```
# Linear Models - best random structure 
```{r}
pH.lm.sat.f<-lmer(pH~Season*siteID + (1|year/month), data= cleaned.final.ph, REML= TRUE)
pH.lm.sat<-lmer(pH~Season*siteID +(1|year), data= cleaned.final.ph, REML= TRUE)


MuMIn::AICc(pH.lm.sat, pH.lm.sat.f)

```

# Linear Models - best fixed structure 
```{r}
pH.lm.sat.f<-lmer(pH~Season*siteID + (1|year/month), data= cleaned.final.ph, REML= FALSE)
pH.lm.sat.season<-lmer(pH~Season +(1|year/month), data= cleaned.final.ph, REML= FALSE)
pH.lm.sat.siteID<-lmer(pH~siteID +(1|year/month), data= cleaned.final.ph, REML= FALSE)
pH.lm.sat.no.int<-lmer(pH~Season +siteID +(1|year/month) , data= cleaned.final.ph, REML= FALSE)
pH.lm.sat.ind<-lmer(pH~1  +(1|year/month), data= cleaned.final.ph, REML= FALSE)

MuMIn::AICc(pH.lm.sat.f, pH.lm.sat.season, pH.lm.sat.siteID, pH.lm.sat.no.int, pH.lm.sat.ind)

# best structure is pH.lm.sat.f
```


# Spatial autocorrelation 
```{r}
library(sp)
library(raster)
library(ape)
coord_invert <- SpatialPoints(cbind(cleaned.final.ph$longitude, cleaned.final.ph$latitude), 
proj4string=CRS("+proj=longlat +ellps=WGS84"))

UTM.US <- spTransform(coord_invert, CRS("+init=epsg:2163")) # US National Atlas Equal Area

dist.matrix <- as.matrix(dist(data.frame(UTM.US)))

inv.dist<- 1/dist.matrix

diag(inv.dist) <- 0

# getting rid of infinite values
inv.dist[is.infinite(inv.dist)] <- 0

Moran.I(cleaned.final.ph$pH, inv.dist, alternative = "two.sided") #p value is 0.59 so pH is not spatially autocorrelated 


```

# FINAL PH MODEL IS: 
```{r}
pH.lm.sat.f<-lmer(pH~Season*siteID + (1|year/month), data= cleaned.final.ph, REML= FALSE)

```

# 2)	Measuring conductance variability across sites and seasons
-	The effect of site, year, and season on conductance: 
o	Simple boxplots by sites and seasons: 3 for each site 
o	test assumptions – do that before running linear model 
o	Run multiple models with different structures: run AIC for the best structure 
o	Account for spatial autocorrelation 
o	Identify which variable to include as random effect (whatever the fixed effect is) 

```{r}
#removed the TECR site since it didn't have any taxonomic data 
df_ph <- df_ph %>% 
  dplyr::select(siteID, year, month, Season, pH, conductance, latitude, longitude) %>% 
  filter(!siteID == "TECR")
```
##assumptions:
```{r}
#visualizing the data across sites 
df_ph %>% 
  ggplot(aes(x=siteID, y=conductance)) + 
  geom_point() 
  
#remove two outliers due to sampling or inputting error 
df_ph_clean<- df_ph %>% 
  filter(conductance < 10000)
df_ph_clean

#this generates 4 plots for normality & homogeneity: 
basic.conductance.lm <- lm(conductance ~ Season*siteID, data=df_ph_clean)
par(mfrow=c(2,2))
plot(basic.conductance.lm)

#ASSESSING NORMALITY:
df_ph_clean %>% 
  ggplot(aes(x=conductance)) + 
  geom_histogram() 
plotNormalHistogram(x=df_ph_clean$conductance)
#this is super non-normal

df_ph_clean %>% 
  ggplot(aes(x=conductance)) + 
  geom_histogram() + 
  facet_wrap(~siteID, scales="free_x")
#there aren't enough observations per site to assess normality

df_ph_clean %>% 
  ggplot(aes(x=conductance)) + 
  geom_histogram() + 
  facet_wrap(~Season, scales="free_x")
#left-skewed for each season

#visualizing the data after applying log transformation to conductance 
#using plotNormalHistogram to have a fitness line superimposed; easier to draw conclusions 
#all of these are much more normally distributed 
plotNormalHistogram(x=log(df_ph_clean$conductance))
plotNormalHistogram(x=log(df_ph_clean$conductance[df_ph_clean$Season=="Spring"]))
plotNormalHistogram(x=log(df_ph_clean$conductance[df_ph_clean$Season=="Summer"]))
plotNormalHistogram(x=log(df_ph_clean$conductance[df_ph_clean$Season=="Fall"]))

#creating a new column with log-transformed conductance values 
df_ph_logged <- df_ph_clean %>% 
  mutate(logged.conductance = log(conductance))

#ASSESSING HOMOGENEITY OF VARIANCE: 
basic.conductance.lm <- lm(conductance ~ Season*siteID, data=df_ph_logged)
par(mfrow=c(2,2))
plot(basic.conductance.lm)
#panel 1 (no funnel shape) & 3 (approximately a horizontal line)
#although not great, the variance is much more equal than before 

#ASSESSING AUTOCORRELATION (IE. INDEPENDANCE OF RESIDUALS): 
lawstat::runs.test(basic.conductance.lm$residuals)
#since pvalue is not significant, that means no autocorrelation :) 

```
summary:
- removed two rows from the data that contained outliers
- plotted histograms for conductance values (all, by site, by season)
  + plotted log transformed conductance values (all, by season)
- created a new dataframe where conductance was log transformed 
- checked autocorrelationa & homogeneity of variance 

##boxplots for each site & season
```{r}
#by season
df_ph_logged %>%
  ggplot(aes(x=Season, y=conductance)) + 
  geom_boxplot() 

#by site 
df_ph_logged %>%
  ggplot(aes(x=siteID, y=conductance)) + 
  geom_boxplot() 
#very messy, basically only tells us there's big differences between sites 

#grouped by site, with each season plotted per site
df_ph_logged %>%
  ggplot(aes(x=Season, y=conductance)) + 
  geom_boxplot() + 
  facet_wrap(~siteID)
```

summary:
- there is not a big difference in conductance between seasons across all sites 
- there are big difference in the conductance between sites across all seasons 
- there doesn't seem to be a big difference in conductance between seasons within sites 
  + caution: not very many data points exist for each season within sites

##linear models
  ```{r}
#saturated model
conductance.lm.sat <- lm(logged.conductance ~ Season*siteID + (1|year/month), data=df_ph_logged)

#optimizing random effect structure 
conductance.lm.sat <- lmer(logged.conductance ~ Season*siteID + (1|year/month), data=df_ph_logged, REML=TRUE)
conductance.lm.year <- lmer(logged.conductance ~ Season*siteID + (1|year) , data=df_ph_logged, REML=TRUE)

MuMIn::AICc(conductance.lm.sat, conductance.lm.year)
#use conductance.lm.year since it has the lower AICc score

#optimizing fixed effected structure 
conductance.lmer1 <- lmer(logged.conductance ~ Season*siteID + (1|year), data=df_ph_logged, REML=FALSE)
conductance.lmer2 <- lmer(logged.conductance ~ Season + (1|year), data=df_ph_logged, REML=FALSE)
conductance.lmer3 <- lmer(logged.conductance ~ siteID + (1|year), data=df_ph_logged,REML=FALSE)
conductance.lmer4 <- lmer(logged.conductance ~ 1 + (1|year), data=df_ph_logged,REML=FALSE)

AICc(conductance.lmer1, conductance.lmer2, conductance.lmer3, conductance.lmer4)
#best structure is: conductance.lmer3 

```
summary: 
- conductance.lmer3 model is the best fit, since lowest AICc score 
  + this is where only siteID is the fixed effect, year is the random effect 
- only site ID predicts conductance
  + conductance value varies based on site 
  + site becomes random effect in final models predicting richness, evenness, etc. since conductance values are non-independant of site

##checking for spatial autocorrelation
```{r}
coord_invert <- SpatialPoints(cbind(df_ph_logged$longitude, df_ph_logged$latitude), proj4string = CRS("+proj=longlat +ellps=WGS84"))

UTM.US <- spTransform(coord_invert, CRS("+init=epsg:2163"))

dist_matrix <- as.matrix(dist(data.frame(UTM.US)))
inv_dist <- 1/dist_matrix
diag(inv_dist) <- 0

#get rid of infinite values 
inv_dist[is.infinite(inv_dist)] <- 0

#moran's I
Moran.I(df_ph_logged$logged.conductance, inv_dist, alternative = "two.sided") 
#pvalue is 2.09x10-6, so conductance is spatially autocorrelated 

```

##removoing site in alaska ("CARI") & rechecking spatial autocorrelation 
```{r}
#visualizing the null model using a variogram 
df_ph_logged <- bind_cols(df_ph_logged, as.data.frame(UTM.US))
df_ph_logged
conductance.null <- gls(logged.conductance ~ siteID, data=df_ph_logged, method="ML")
plot(Variogram(conductance.null, form = ~coords.x1+coords.x2, resType = "normalized"))
##it appears that one point is an outlier - the comparison is of locations that are very far from each other 
##we could try excluding the alaska site (cari) to see if it resolves the issue of spatial autocorrelation

#excluding mayf site in alaska 
conductance.cari.out <- df_ph_logged %>% 
  filter(!siteID == "CARI")
conductance.null <- gls(logged.conductance ~ siteID, data=conductance.cari.out, method="ML")
plot(Variogram(conductance.null, form = ~coords.x1+coords.x2, resType = "normalized"))
##the semivariogram now has a decreasing slope

#calculating moran's i without "cari" site
coord_invert.cari.out <- SpatialPoints(cbind(conductance.cari.out$longitude, conductance.cari.out$latitude), proj4string = CRS("+proj=longlat +ellps=WGS84"))
UTM.US <- spTransform(coord_invert.cari.out, CRS("+init=epsg:2163"))

dist_matrix.cari.out <- as.matrix(dist(data.frame(UTM.US)))
inv_dist.cari.out <- 1/dist_matrix.cari.out
diag(inv_dist.cari.out) <- 0
inv_dist.cari.out[is.infinite(inv_dist.cari.out)] <- 0

Moran.I(conductance.cari.out$logged.conductance, inv_dist.cari.out, alternative = "two.sided") 
##pvalue << 0.05, so there is still signficant spatial autocorrelation - in this case it's oddly negative 
```
summary: 
- the pvalue for moran's i with all the sites included was << 0.05, indicating that there was spatial autocorrelation in the data
  + some points were more similar depending on distance
  + we noticed in the variogram that there was one outlier point (high semivariance, far distance), which might have been skewing the data 
- reran moran's i & a semivariogram, and found that spatial autocorrelation was still significant 
  + however, it was negatively significant - increasing distance between sites made variance decrease


# 3)	Measuring Simpson’s Index across sites 
o	Convert species data to a matrix 
o	Spatial autocorrelation 
o	Use Simpson’s function to quantify richness 

## Simpson's index of diversity
```{r}
ig_all <- read_csv("invert.genera.season.csv", col_names = TRUE)

ig_simpson <- ig_all %>%
  group_by(siteID, collectDate) %>%
  summarise(simpson = diversity(estimatedTotalCount, index = "simpson"),
            richness = specnumber(estimatedTotalCount)) 
ig_all_simpson <- inner_join(ig_all, ig_simpson)
```
## Is the simpson's index spatially autocorrelated?
### richness 
```{r}
Moran.I(ig_all_simpson$richness, inv.dist, alternative = "two.sided") # p < 0.05, therefore it is spatially autocorrelated.
```
### simpson's index
```{r}
Moran.I(ig_all_simpson$simpson, inv.dist, alternative = "two.sided") 
# p = 0.01546975 < 0.05, therefore it is spatially autocorrelated.
```

# 4)	Measure correlation between %Riparian Cover and other variables 
o	Measure correlation between riparian cover, land use, seasonality and site 
o	Account for spatial autocorrelation 
o	Identify which variable to include as random effect (whatever the fixed effect is) 

```{r}
riparian_data <- read_csv("FINAL.RIP.GEO.csv", col_names = TRUE)
```
```{r}
# added season to riparian data just in case we need it. can delete later if we dont use it.
rd_spring<- riparian_data %>%
  filter(month >=3, month <= 5) %>%
  mutate(season = "Spring")

rd_summer<- riparian_data %>%
  filter(month >=6, month <= 8) %>%
  mutate(season = "Summer")

rd_fall<- riparian_data %>%
  filter(month >=9, month <= 11) %>%
  mutate(season = "Fall")

riparian_data_season <- rbind(rd_spring, rd_summer, rd_fall) 
```
## Spatial autocorrelation between riparian cover and sites

```{r}
Moran.I(riparian_data$mean_canopy, inv.dist, alternative = "two.sided")
#p.value = 0.603 so its not spatially correlated. 
```
## Correlation between riparian cover and other variables
### with month
```{r}
# see March and April have lower canopy cover than other month.
riparian_data %>%
  mutate(month = as.factor(month)) %>%
  ggplot(aes(x = month, y = mean_canopy)) +
  geom_boxplot()
```
### with season
```{r}
# see March and April have lower canopy cover than other month, don't see that difference in seasons. 
riparian_data_season %>%
  ggplot(aes(x = season, y = mean_canopy)) +
  geom_boxplot()
```
### with site
```{r}
# sites do differ in canopy cover between each other 
riparian_data %>%
  ggplot(aes(x = siteID, y = mean_canopy, color = siteID))+
  geom_boxplot()
```
### with year 
```{r}
# each years are similar 
riparian_data %>%
  mutate(year = as.factor(year)) %>%
  ggplot(aes(x = year, y = mean_canopy))+
  geom_boxplot()
```
### with land use
```{r}
# slightly positive relationtship 
riparian_data %>%
  ggplot(aes(x = summed_landuse, y = mean_canopy)) +
  geom_point() +
  geom_smooth(method = "lm")
```
### correlation between site and land use
```{r}
# some sites have zero land use. 
riparian_data %>%
  ggplot(aes(x = siteID, y = summed_landuse)) +
  geom_boxplot()
```

# 5)	Either linear model or mixed model to measure effect of pH, conductance, and riparian cover on Species Richness 
o	Need to account for spatial autocorrelation from step 3 
o	Model structure will depend on results from step 1, 2, and 4

# 7)	Measuring Shannon’s Index across sites 
o	Convert species data to a matrix 
o	Spatial autocorrelation 
o	Use Simpson’s function to quantify richness 

## Evenness
```{r}
invert_evenness <- invert_genera %>%
  group_by(siteID, collectDate) %>%
  summarise(shannon = diversity(estimatedTotalCount, index = "shannon"),
            evenness = shannon/log(specnumber(estimatedTotalCount))) 
```

## Is evenness spatially autocorrelated?
```{r}
Moran.I(invert_evenness_coords$evenness, inv.dist, alternative = "two.sided") ## p = 0.432 so it is not.
```

# 8)	Either linear model or mixed model to measure effect of pH on Species evenness  
o	Need to account for spatial autocorrelation from step 3 
o	Model structure will depend on results from step 1 

# 9)	Either linear model or mixed model to measure effect of conductance on Species evenness  
o	Need to account for spatial autocorrelation from step 3 
o	Model structure will depend on results from step 2

# 10)	Either linear or mixed model to measure the effect of riparian cover on species richness 
o	Need to account for spatial autocorrelation from step 3 
o	Model structure will depend on results from step 2

# 11)	Either linear model or mixed model to measure effect of riparian cover on Species evenness  
o	Need to account for spatial autocorrelation from step 3 
o	Model structure will depend on results from step 2
