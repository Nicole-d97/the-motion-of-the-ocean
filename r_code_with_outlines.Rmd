## packages needed

```{r}
library (readr) 
library(vegan)
library(ggplot)
library(tidyverse)
library(sp)
library(raster)
library(ape)
library(lawstat) 
library(MuMIn) 
```

## files needed

```{r}
invert_genera <- read_csv("invert.genera.season.csv")
cleaned.final.ph <- read_csv("FINAL.PH.GEO.csv") 
```

## Map of the sites

```{r}
map.US <- map_data("world", region = "USA")

invert_genera %>%
  ggplot() + 
  geom_polygon(data = map.US, aes(x = long, y = lat, group = group), fill = NA, colour = "gray") + 
  coord_fixed() + 
  geom_point(data = invert_genera, aes(x = decimalLongitude.x, y = decimalLatitude.x)) + 
  xlim(-200, -50) + 
  xlab("Longitude") + ylab("Latitude")
```

## Inverse distance weight matrix for testing spatial autocorrelation

```{r}
coord_invert <- SpatialPoints(cbind(invert_evenness_coords$decimalLongitude, invert_evenness_coords$decimalLatitude), 
proj4string=CRS("+proj=longlat +ellps=WGS84"))

UTM.US <- spTransform(coord_invert, CRS("+init=epsg:2163")) # US National Atlas Equal Area

dist.matrix <- as.matrix(dist(data.frame(UTM.US)))

inv.dist<- 1/dist.matrix

diag(inv.dist) <- 0

# getting rid of infinite values
inv.dist[is.infinite(inv.dist)] <- 0
```

# 1)	Measuring pH variability across sites and seasons
-	The effect of site, year, and season on pH:
o	Simple boxplots by sites and seasons: 3 for each site 
o	there is code that tests for 4 assumptions of normality – do that before running linear model 
o	Run multiple models with different structures: run AIC for the best structure 
o	Account for spatial autocorrelation 
o	Identify which variable to include as random effect (whatever the fixed effect is) 

``` {r}
# Removing outliers that don't fit within the normal range of pH values (ie. 0-14)
cleaned.final.ph<- FINAL.PH %>% 
  filter(pH < 14 & pH > 0)
cleaned.final.ph

# Testing for normality - overall pH 
cleaned.final.ph %>% 
ggplot(aes(x= pH)) + 
  geom_histogram()

# Testing for normality - pH by season 
cleaned.final.ph %>% 
ggplot(aes(x= pH)) + 
  geom_histogram() + 
  facet_wrap(~Season)

# Testing for normality - pH by siteID
cleaned.final.ph %>% 
ggplot(aes(x= pH)) + 
  geom_histogram() + 
  facet_wrap(~siteID)

# Testing for normality - pH by year 
cleaned.final.ph %>% 
ggplot(aes(x= pH)) + 
  geom_histogram() + 
  facet_wrap(~year)

# Testing for normality - pH by month
cleaned.final.ph %>% 
ggplot(aes(x= pH)) + 
  geom_histogram() + 
  facet_wrap(~month)
# not enough data by month = removed from pH.lm 

# Model that includes all as fixed effects 
pH.lm<- lm(pH~Season*siteID, data= cleaned.final.ph)

par(mfrow=c(2,2))
plot(pH.lm)
# Looking at panels 1 and 2, the data is homogenous and normally distributed 

# boxplots to visualize variation in pH across sites 
cleaned.final.ph %>% 
  ggplot(aes(x= siteID, y= pH))+ 
  geom_boxplot()

# boxplots to visualize variation in pH across seasons 
cleaned.final.ph %>% 
  ggplot(aes(x= Season, y= pH))+ 
  geom_boxplot()

# boxplots to visualize variation in pH across seasons and sites
cleaned.final.ph %>% 
  ggplot(aes(x= Season, y= pH))+ 
  geom_boxplot() + 
  facet_wrap(~siteID)

# Independence of residuals 
lawstat::runs.test(pH.lm$residuals)
# p value is 0.08 -> i.e no autocorrelation 

# Saturated Model 
```{r}
pH.lm.sat<-lmer(pH~Season*siteID +(1|year) +(1|month), data= cleaned.final.ph)
summary(pH.lm.sat)
```


# AIC values 
```{r}
cleaned.final.ph

n<- 74 
k<- 4 

AIC_mod <- n/k 

AIC_mod

#USING AICc because n/k is 18.5 (i.e less than 40)

```
# Linear Models - best random structure 
```{r}
pH.lm.sat.f<-lmer(pH~Season*siteID + (1|year/month), data= cleaned.final.ph, REML= TRUE)
pH.lm.sat<-lmer(pH~Season*siteID +(1|year), data= cleaned.final.ph, REML= TRUE)


MuMIn::AICc(pH.lm.sat, pH.lm.sat.f)

```

# Linear Models - best fixed structure 
```{r}
pH.lm.sat.f<-lmer(pH~Season*siteID + (1|year/month), data= cleaned.final.ph, REML= FALSE)
pH.lm.sat.season<-lmer(pH~Season +(1|year/month), data= cleaned.final.ph, REML= FALSE)
pH.lm.sat.siteID<-lmer(pH~siteID +(1|year/month), data= cleaned.final.ph, REML= FALSE)
pH.lm.sat.no.int<-lmer(pH~Season +siteID +(1|year/month) , data= cleaned.final.ph, REML= FALSE)
pH.lm.sat.ind<-lmer(pH~1  +(1|year/month), data= cleaned.final.ph, REML= FALSE)

MuMIn::AICc(pH.lm.sat.f, pH.lm.sat.season, pH.lm.sat.siteID, pH.lm.sat.no.int, pH.lm.sat.ind)

# best structure is pH.lm.sat.f
```


# Spatial autocorrelation 
```{r}
library(sp)
library(raster)
library(ape)
coord_invert <- SpatialPoints(cbind(cleaned.final.ph$longitude, cleaned.final.ph$latitude), 
proj4string=CRS("+proj=longlat +ellps=WGS84"))

UTM.US <- spTransform(coord_invert, CRS("+init=epsg:2163")) # US National Atlas Equal Area

dist.matrix <- as.matrix(dist(data.frame(UTM.US)))

inv.dist<- 1/dist.matrix

diag(inv.dist) <- 0

# getting rid of infinite values
inv.dist[is.infinite(inv.dist)] <- 0

Moran.I(cleaned.final.ph$pH, inv.dist, alternative = "two.sided") #p value is 0.59 so pH is not spatially autocorrelated 


```

# FINAL PH MODEL IS: 
```{r}
pH.lm.sat.f<-lmer(pH~Season*siteID + (1|year/month), data= cleaned.final.ph, REML= FALSE)

```

# 2)	Measuring conductance variability across sites and seasons
-	The effect of site, year, and season on conductance: 
o	Simple boxplots by sites and seasons: 3 for each site 
o	**somewhere in lecture** there is code that tests for 4 assumptions of normality – do that before running linear model 
o	Run multiple models with different structures: run AIC for the best structure 
o	Account for spatial autocorrelation 
o	Identify which variable to include as random effect (whatever the fixed effect is) 

# 3)	Measuring Simpson’s Index across sites 
o	Convert species data to a matrix 
o	Spatial autocorrelation 
o	Use Simpson’s function to quantify richness 

## Simpson's index of diversity
```{r}
ig_all <- read_csv("invert.genera.season.csv", col_names = TRUE)

ig_simpson <- ig_all %>%
  group_by(siteID, collectDate) %>%
  summarise(simpson = diversity(estimatedTotalCount, index = "simpson"),
            richness = specnumber(estimatedTotalCount)) 
ig_all_simpson <- inner_join(ig_all, ig_simpson)
```
## Is the simpson's index spatially autocorrelated?
### richness 
```{r}
Moran.I(ig_all_simpson$richness, inv.dist, alternative = "two.sided") # p < 0.05, therefore it is spatially autocorrelated.
```
### simpson's index
```{r}
Moran.I(ig_all_simpson$simpson, inv.dist, alternative = "two.sided") 
# p = 0.01546975 < 0.05, therefore it is spatially autocorrelated.
```

# 4)	Measure correlation between %Riparian Cover and other variables 
o	Measure correlation between riparian cover, land use, seasonality and site 
o	Account for spatial autocorrelation 
o	Identify which variable to include as random effect (whatever the fixed effect is) 

```{r}
riparian_data <- read_csv("FINAL.RIP.GEO.csv", col_names = TRUE)
```
```{r}
# added season to riparian data just in case we need it. can delete later if we dont use it.
rd_spring<- riparian_data %>%
  filter(month >=3, month <= 5) %>%
  mutate(season = "Spring")

rd_summer<- riparian_data %>%
  filter(month >=6, month <= 8) %>%
  mutate(season = "Summer")

rd_fall<- riparian_data %>%
  filter(month >=9, month <= 11) %>%
  mutate(season = "Fall")

riparian_data_season <- rbind(rd_spring, rd_summer, rd_fall) 
```
## Spatial autocorrelation between riparian cover and sites

```{r}
Moran.I(riparian_data$mean_canopy, inv.dist, alternative = "two.sided")
#p.value = 0.603 so its not spatially correlated. 
```
## Correlation between riparian cover and other variables
### with month
```{r}
# see March and April have lower canopy cover than other month.
riparian_data %>%
  mutate(month = as.factor(month)) %>%
  ggplot(aes(x = month, y = mean_canopy)) +
  geom_boxplot()
```
### with season
```{r}
# see March and April have lower canopy cover than other month, don't see that difference in seasons. 
riparian_data_season %>%
  ggplot(aes(x = season, y = mean_canopy)) +
  geom_boxplot()
```
### with site
```{r}
# sites do differ in canopy cover between each other 
riparian_data %>%
  ggplot(aes(x = siteID, y = mean_canopy, color = siteID))+
  geom_boxplot()
```
### with year 
```{r}
# each years are similar 
riparian_data %>%
  mutate(year = as.factor(year)) %>%
  ggplot(aes(x = year, y = mean_canopy))+
  geom_boxplot()
```
### with land use
```{r}
# slightly positive relationtship 
riparian_data %>%
  ggplot(aes(x = summed_landuse, y = mean_canopy)) +
  geom_point() +
  geom_smooth(method = "lm")
```
### correlation between site and land use
```{r}
# some sites have zero land use. 
riparian_data %>%
  ggplot(aes(x = siteID, y = summed_landuse)) +
  geom_boxplot()
```

# 5)	Either linear model or mixed model to measure effect of pH, conductance, and riparian cover on Species Richness 
o	Need to account for spatial autocorrelation from step 3 
o	Model structure will depend on results from step 1, 2, and 4

# 7)	Measuring Shannon’s Index across sites 
o	Convert species data to a matrix 
o	Spatial autocorrelation 
o	Use Simpson’s function to quantify richness 

## Evenness
```{r}
invert_evenness <- invert_genera %>%
  group_by(siteID, collectDate) %>%
  summarise(shannon = diversity(estimatedTotalCount, index = "shannon"),
            evenness = shannon/log(specnumber(estimatedTotalCount))) 
```

## Is evenness spatially autocorrelated?
```{r}
Moran.I(invert_evenness_coords$evenness, inv.dist, alternative = "two.sided") ## p = 0.432 so it is not.
```

# 8)	Either linear model or mixed model to measure effect of pH on Species evenness  
o	Need to account for spatial autocorrelation from step 3 
o	Model structure will depend on results from step 1 

# 9)	Either linear model or mixed model to measure effect of conductance on Species evenness  
o	Need to account for spatial autocorrelation from step 3 
o	Model structure will depend on results from step 2

# 10)	Either linear or mixed model to measure the effect of riparian cover on species richness 
o	Need to account for spatial autocorrelation from step 3 
o	Model structure will depend on results from step 2

# 11)	Either linear model or mixed model to measure effect of riparian cover on Species evenness  
o	Need to account for spatial autocorrelation from step 3 
o	Model structure will depend on results from step 2
